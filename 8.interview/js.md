# JS

#### 자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라

string
number
bigint
boolean
symbol
null - null 타입 변수의 경우는 명시적으로 값이 비어있음 (no value)
의미없는 특별한 값이 등록
undefined - 값이 할당되지 않은 변수
등록이 되어있지 않기 때문에 초기화도 정의되지도 않은 것입니다.

#### 스코프체인, 렉시컬 스코프

js에서 전역변수는 window객체에 변수를 만드는 것.
지역변수는 아무리 해도 전역변수에 영향을 끼칠 수 없습니다. 바로 함수 스코프 때문이죠. 범위라는 말처럼 함수 안에서 선언된 변수는 해당 함수 안에서만 사용할 수 있습니다.

스코프 체인(scope chain)이란 개념이 나옵니다. 내부 함수에서는 외부 함수의 변수에 접근 가능하지만 외부 함수에서는 내부 함수의 변수에 접근할 수 없습니다. 그리고 모든 함수들은 전역 객체에 접근할 수 있죠.

렉시컬 스코핑(lexical scoping)
스코프는 함수를 호출할 때가 아니라 선언할 때 생깁니다. 호출이 아니라 선언요! 정적 스코프라고도 불립니다.
함수를 처음 선언하는 순간, 함수 내부의 변수는 자기 스코프로부터 가장 가까운 곳(상위 범위에서)에 있는 변수를 계속 참조하게 됩니다.

전역변수를 만드는 일은 지양하라고 했는데, 그 이유는 변수가 섞일 수 있기 때문입니다.

#### 실행 컨텍스트

자바스크립트 실행 컨텍스트는 코드의 실행 환경이다.

처음 코드를 실행(여기서 실행은 브라우저가 스크립트를 로딩해서 실행하는 걸 말합니다)하는 순간 모든 것을 포함하는 전역 컨텍스트가 생깁니다. 모든 것을 관리하는 환경입니다. 페이지가 종료될 때까지 유지됩니다. 전역 컨텍스트 말고도 함수 컨텍스트가 있는데요. 전 시간에 자바스크립트는 함수 스코프를 따른다고 했죠? 함수를 호출할 때마다 함수 컨텍스트가 하나씩 더 생깁니다.

- 먼저 전역 컨텍스트 하나 생성 후, 함수 호출 시마다 컨텍스트가 생깁니다.
- 컨텍스트 생성 시 컨텍스트 안에 변수객체(arguments, variable), scope chain, this가 생성됩니다.
- 컨텍스트 생성 후 함수가 실행되는데, 사용되는 변수들은 변수 객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾습니다.
- 함수 실행이 마무리되면 해당 컨텍스트는 사라집니다.(클로저 제외) 페이지가 종료되면 전역 컨텍스트가 사라집니다.

scope chain은 자기 자신인 전역 변수객체입니다. this는 따로 설정되어 있지 않으면 window입니다. this를 바꾸는 방법이 바로 new를 호출하는 겁니다. (또는 함수에 다른 this 값을 bind할 수도 있습니다) 일반 함수의 this가 왜 window인지 아시겠죠? 원래 기본적으로 window고 new나 bind같은 상황에서 this가 바뀌는 겁니다.

함수 컨텍스트

함수가 실행 되는 순간 함수 컨텍스트가 전역 컨텍스트 위에 올라감(stack)

#### 호이스팅

호이스팅이란 변수를 선언하고 초기화했을 때 선언 부분이 최상단으로 끌어올려지는 현상을 의미합니다. (초기화 또는 대입 부분은 그대로 남아있습니다) 아래처럼 sayWow처럼 함수 표현식이 아니라 함수 선언식일 때는 식 자체가 통째로 끌어올려집니다.

#### 클로져

클로저 함수 내부에 생성한 변수도 아니고, 매개변수도 아닌 변수 즉 비공개 변수를 가질 수 있는 환경에 있는 함수가 클로저입니다.
js의 모든 함수는 환경변수를 가지는데 환경변수는 숨김 프로퍼티인 `[[Environment]]`를 이용해 자신이 어디서 만들어졌는지를 기억합니다. 함수 내부의 코드는 `[[Environment]]`를 사용해 외부 변수에 접근합니다

비공개 변수이기 때문에 남들이 조작할 걱정은 없죠. 프로그램 사용자는 여러분이 공개한 메소드만 사용해야합니다. 사용자가 예상을 뒤엎는 행동을 하는 것을 막을 수 있죠. 꼭 알아두어야 할 점은 절대로 사용자를 믿어서는 안됩니다. 무슨 짓을 할 지 모르거든요. 해킹을 시도할 수도 있고, 프로그램에 버그를 만들 수도 있습니다. 특히 서버와 연결되어 있는 경우는 더 조심해야하죠. 그렇기때문에 항상 사용자가 할 수 있는 모든 행동과 일어날 수 있는 경우의 수를 통제하고 있어야합니다. 자바스크립트에서 사용자를 통제하기 위한 기본적인 방법이 바로 클로저입니다.

단점으로는 잘못 사용했을 시 성능 문제와 메모리 문제가 발생할 수 있습니다. closure의 비공개 변수는 자바스크립트에서 언제 메모리 관리를 해야할 지 모르기 때문에 자칫 메모리 낭비로 이어질 수 있습니다.

#### 자바스크립트 프로토타입이란?

`[[Prototype]]`이 참조하는 객체, 즉 자신을 만들어낸 객체의 원형을 뜻한다.
JavaScript 객체는 다른 객체에 대한 참조인 `__proto__` 프로퍼티를 가지고 있습니다.

```
let animal = {
eats: true
};
let rabbit = {
jumps: true
};

rabbit.__proto__ = animal;
// console 함수가 rabbit.eats 프로퍼티를 읽으려 했는데, rabbit엔 eats라는 프로퍼티가 없습니다.
// 이때 자바스크립트는 [[Prototype]]이 참조하고 있는 객체인 animal에서 eats를 얻어냅니다.

console.log(rabbit.eats); // true
```

`**proto**`는 브라우저를 대상으로 개발하고 있다면 다소 구식이기 때문에 더는 사용하지 않는 것이 좋습니다. 표준에도 관련 내용이 명시되어있습니다.

대신 아래와 같은 모던한 메서드들을 사용하는 것이 좋죠.

Object.create(proto, descriptors) – `[[Prototype]]`이 proto를 참조하는 빈 객체를 만듭니다. 이때 프로퍼티 설명자를 추가로 넘길 수 있습니다.
Object.getPrototypeOf(obj) – obj의 `[[Prototype]]`을 반환합니다.
Object.setPrototypeOf(obj, proto) – obj의 `[[Prototype]]`이 proto가 되도록 설정합니다

#### 호출스택과 이벤트루프

자바스크립트는 보통 싱글 쓰레드라고 불리는데, 바로 메인 쓰레드인 이벤트 루프가 싱글 쓰레드이기 때문입니다.

이벤트 루프 돌아가는 과정

1. 호출스택
2. 백그라운드
3. 태스크 큐

- 비동기 함수가 실행되면 백그라운드로 이동하고 그 다음 과정 진행
- 비동기 과정이 끝나면 태스크 큐로 이동
- 호출 스택 실행이 끝나 비워지면
- 태스크 큐의 콜백을 호출스택으로 올림(우선순위 존재)
-

#### 자바스크립트 this란?

ex) 화살표 함수, call, bind, apply 등

this는 기본적으로 window임(스코프체인)
객체 메서드안에서 this는 객체를 가르킴
명시적으로 this를 바꾸는 함수 메서드 삼총사 bind, call, apply를 사용하면 this가 객체를 가리킵니다.
call,apply,bind는 직접 함수가 실행문맥을 결정한다.
call,apply는 함수를 실행해서 그 함수의 값을, bind 지정한 객체의 새로운 함수를 만든다.
쉽게 말해, call,apply는 그냥 함수가 실행되도록 "도와"주는 것이고 bind 는 "새로운" 함수를 "만들어" 준다.

마지막으로 생성자의 경우입니다. 처음부터 공포스러운 this를 쓰는 무시무시한 친구입니다.

```
function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype.sayHi = function() {
  console.log(this.name, this.age);
}
```

일반 함수의 this는 window기 때문에 new 를 사용해줘야함.
new를 붙이면 this가 생성자를 통해 생성된 인스턴스(hero 자신)가 됩니다.

#### 자바스크립트 이벤트 관리 방법? 보통 어떤 식으로 이벤트를 설계해야 하는지?

ex) 이벤트 캡처링 & 버블링
ex) 이벤트 등록 & 해제
ex) 이벤트 위임 방식 등

이벤트리스너를 사용하면 이벤트가 발생할 때, 내부적으로 this를 바꿨음에도 명시적으로 알리지 않음.

버블링

한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작합니다.
가장 안쪽의 `<p>`를 클릭하면 순서대로 다음과 같은 일이 벌어집니다.

1. `<p>`에 할당된 onclick 핸들러가 동작합니다.
2. 바깥의 `<div>`에 할당된 핸들러가 동작합니다.
3. 그 바깥의 `<form>`에 할당된 핸들러가 동작합니다.
4. document 객체를 만날 때까지, 각 요소에 할당된 onclick 핸들러가 동작합니다.

이벤트가 발생한 가장 안쪽의 요소는 타깃(target) 요소라고 불리고, event.target을 사용해 접근할 수 있습니다.

캡처링

이벤트엔 버블링 이외에도 ‘캡처링(capturing)’ 이라는 흐름이 존재합니다. 실제 코드에서 자주 쓰이진 않지만, 종종 유용한 경우가 있으므로 알아봅시다.

표준 DOM 이벤트에서 정의한 이벤트 흐름엔 3가지 단계가 있습니다.

- 캡처링 단계 – 이벤트가 하위 요소로 전파되는 단계
- 타깃 단계 – 이벤트가 실제 타깃 요소에 전달되는 단계
- 버블링 단계 – 이벤트가 상위 요소로 전파되는 단계

캡처링 단계에서 이벤트를 잡아내려면 addEventListener의 capture 옵션을 true로 설정해야 합니다.

```
elem.addEventListener(..., {capture: true})
// 아니면, 아래 같이 {capture: true} 대신, true를 써줘도 됩니다.
elem.addEventListener(..., true)
// false이면(default 값) 핸들러는 버블링 단계에서 동작합니다.
// true이면 핸들러는 캡처링 단계에서 동작합니다.
```

이벤트 위임

이벤트 위임은 비슷한 방식으로 여러 요소를 다뤄야 할 때 사용됩니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않고, 요소의 공통 조상에 이벤트 핸들러를 단 하나만 할당해도 여러 요소를 한꺼번에 다룰 수 있습니다.

상위요소에 이벤트를 거는데 클릭시 타겟으로 어떤요소가 클릭되었는 지 강조

```
table.onclick = function(event) {
  let td = event.target.closest('td'); // (1)
  if (!td) return; // (2)
  if (!table.contains(td)) return; // (3)
  highlight(td); // (4)
};

```

1. elem.closest(selector) 메서드는 elem의 상위 요소 중 selector와 일치하는 가장 근접한 조상 요소를 반환합니다. 위 코드에선 이벤트가 발생한 요소부터 시작해 위로 올라가며 가장 가까운 `<td>` 요소를 찾습니다.
2. event.target이 `<td>`안에 있지 않으면 그 즉시 null을 반환하므로 아무 작업도 일어나지 않습니다.
3. 중첩 테이블이 있는 경우 event.target은 현재 테이블 바깥에 있는 `<td>`가 될 수도 있습니다. 이런 경우를 처리하기 위해 `<td>`가 팔괘도 안에 있는지를 확인합니다.
4. 이제 진짜 td를 강조해 줍니다.

https://ko.javascript.info/event-delegation

#### 자바스크립트 비동기 처리에 대한 설명

ex) 콜백, 프로미스, async await
ex) 비동기 처리의 특성 및 에러 처리 방법?

프로미스 es6, async await es8

자바스크립트의 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미합니다.(특정 로직의 실행이 끝날 때까지 기다려주지 않고 나머지 코드를 먼저 실행하는 것이 비동기 처리)

웹 서비스를 개발하다 보면 서버에서 데이터를 받아와 화면에 표시하기까지 인코딩, 사용자 인증 등을 처리해야 하는 경우가 있습니다. 만약 이 모든 과정을 비동기로 처리해야 한다고 하면 위와 같이 콜백 안에 콜백을 계속 무는 형식으로 코딩을 하게 됩니다. 이러한 코드 구조는 가독성도 떨어지고 로직을 변경하기도 어렵습니다. 이와 같은 코드 구조를 콜백 지옥이라고 합니다.

Promise는 자바스크립트 비동기 처리에 사용되는 객체

프로미스의 3가지 상태(states)
프로미스를 사용할 때 알아야 하는 가장 기본적인 개념이 바로 프로미스의 상태(states)입니다. 여기서 말하는 상태란 프로미스의 처리 과정을 의미합니다. new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.

Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태
Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

1.  new Promise() 메서드를 호출하면 대기(Pending) 상태가 됩니다.
2.  콜백 함수의 인자 resolve를 아래와 같이 실행하면 이행(Fulfilled) 상태가 됩니다. 이행 상태가 되면 아래와 같이 then()을 이용하여 처리 결과 값을 받을 수 있습니다.
3.  여기서 reject를 아래와 같이 호출하면 실패(Rejected) 상태가 됩니다. 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 catch()로 받을 수 있습니다.

async/ await

async/ await는 ES8문법으로서 가장 최근에 나온 문법이다. 콜백함수와 promise의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성하게 도와준다.

async/await는 promise를 기반으로 하있다.
모든 async함수는 promise를 리턴하고, 모든 await함수는 일반적으로 promise가 된다.
await를 만나면 promise가 처리될 때 까지 기다린다. 결과는 그 이후에 변환된다.

async & await에서 예외를 처리하는 방법은 바로 try-catch이다. 프로미스에서 에러 처리를 위해 .catch()를 사용했던 것처럼 async에서는 catch {} 를 사용하면 된다.

### 프런트엔드 빌드 시스템에 대해서 설명해보세요.

#### 웹팩이란? 모듈 번들러가 무엇인가요?

자바스크립트 코드가 많아지면 하나의 파일로 관리하는데 한계가 있다. 그렇다고 여러개 파일을 브라우져에서 로딩하는 것은 그만큼 네트웍 비용을 치뤄야하는 단점이 있다. 뿐만 아니라 각 파일은 서로의 스코프를 침범하지 않아야 하는데 잘못 작성할 경우 변수 충돌의 위험성도 있다.

웹팩(Webpack)은 의존성을 분석해 모듈을 번들(여러 개를 하나로 묶어주는)시켜주는 역할을 한다. 프로젝트를 개발하다보면 수 많은 라이브러리들을 사용하게 되는데 빌드(build)라는 과정을 통해 하나의 파일로 짠!하고 만들어 준다.

#### 바벨이란?

ES6+ 버전의 자바스크립트나 타입스크립트, JSX 등 다른 언어로 분류되는 언어들에 대해서도 모든 브라우저에서 동작할 수 있도록 호환성을 지켜준다. 바벨은 이렇게 추상화 수준을 유지한 채로 코드를 변화시키는 트랜스파일러의 역할을 한다. 바벨을 통해 ES6+의 자바스크립트 코드는 하위 버전으로 변환되고, 그로 인해 IE나 다른 브라우저에서 동작할 수 있게 만든다.
바벨은 최신문법이나 실험적문법을 JS파일에서 사용할 수 있게 해줌

#### 폴리필이란?

폴리필(polyfill)은 최신 ECMAScript 환경을 만들기 위해 코드가 실행되는 환경에 존재하지 않는 빌트인, 메소드 등을 추가하는 역할을 한다.
바벨의 경우는 ES6+를 ES5로 변환할 수 있는 것들만 변환을 하는데, Promise와 같이 ES5에서 변환할 수 있는 대상이 없는 경우는 에러가 발생한다. 이러한 경우 우리는 폴리필을 통해서 이슈를 해결할 수 있다. Promise를 ES5로 변환할 수는 없지만 ES5 방식으로 구현하여 해결하는 것이다.

#### Node.js란?

JS 실행기

#### NPM이란?

node.js의 버전관리 시스템(yarn도 있음)

#### ESLint란?

보프라기 있는 옷을 입을 수는 있듯이 이러한 코드로 만든 어플리케이션도 동작은 한다. 그러나 코드의 가독성이 떨어지고 점점 유지보수하기 어려운 애물단지가 되어버리기 일쑤다.

보푸라기를 제거하는 린트 롤러(Lint roller)처럼 코드의 오류나 버그, 스타일 따위를 점검하는 것을 린트(Lint) 혹은 린터(Linter)라고 부른다.

대부분의 프로그래밍 언어에는 컴파일하는 과정에서 수행되는 Linter가 기본적으로 내장되어 있다.
그러나, 역동적이고 느슨한 언어인 JavaScript는 Linter가 존재하지 않는다.

ESLint는 ECMAScript 코드에서 문제점을 검사하고 일부는 더 나은 코드로 정정하는 린트 도구 중의 하나다.

코드에서 검사하는 항목을 크게 분류하면 아래 두 가지다.

- 포맷팅
  포맷팅은 일관된 코드 스타일을 유지하도록 하고 개발자로 하여금 쉽게 읽히는 코드를 만들어 준다. 이를 테면 "들여쓰기 규칙", "코드 라인의 최대 너비 규칙"을 따르는 코드가 가독성이 더 좋다.

- 코드 품질
  한편, 코드 품질은 어플리케이션의 잠재적인 오류나 버그를 예방하기 위함이다. 사용하지 않는 변수 쓰지 않기, 글로벌 스코프 함부로 다루지 않기 등이 오류 발생 확률을 줄여 준다.

#### Prettier란?

Prettier은 VSCode 익스텐션 중에 코드를 정렬해 주는 Code Formatter 중 하나이다.
설정한 ESLint 룰에 따라 Prettier가 자동으로 format을 잡아준다.

#### 웹 태스크 매니저란?

이전부터 프런트엔드 개발 업무를 할 때 가장 많이 반복하는 작업은 텍스트 편집기에서 코드를 수정하고 저장한 뒤 브라우저에서 새로 고침을 누르는 것이었습니다. 그래야 화면에 변경된 내용을 볼 수 있었죠.

이외에도 웹 서비스를 개발하고 웹 서버에 배포할 때 아래와 같은 작업들을 해야 했습니다.

- HTML, CSS, JS 압축
- 이미지 압축
- CSS 전처리기 변환
  이러한 일들을 자동화 해주는 도구들이 필요했습니다. 그래서 Grunt와 Gulp 같은 도구들이 등장했습니다.

#### ES6 크롬 정도의 브라우저를 제외하곤 ES6 스펙에 대한 지원이 완벽하지 않다. 해결방법은 무엇인가

바벨 && 폴리필

#### ES6에 새로 생긴 것을 아는대로 말해달라.

- 변수의 선언방식
  - 기존의 var는 함수형 스코프였지만 let, const는 블록 스코프
  - let 변수, const 상수
- 템플릿 리터럴
  - ${}
- Arrow Functions
  - const function = (Parameter) => {...}
- Default Parameter Values // 함수의 파라메터에 기본값 설정
- Function Rest Parameter // 스프레드연산자
- Symbol
  - 자바스크립트는 객체 프로퍼티 키로 오직 문자형과 심볼형만을 허용합니다.
  - '심볼(symbol)'은 유일한 식별자(unique identifier)를 만들고 싶을 때 사용
  - https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol
- module시스템
  - import name from 경로
  - export default, export
- Class
  - 하지만 내부적으로는 그대로 프로토타입을 따릅니다.
- Promise // 비동기 함수

#### var 와 let, const의 가장 큰 차이점은 무엇인가 (function scope와 block scope의 개념에서)

기존의 var는 함수형 스코프였지만 let, const는 블록 스코프

#### Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가

JS는 class가 없었지만, ES6때 추가 되었음.

클래스는 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀이고 그 틀로 생성한 객체는 인스턴스다.(메모리 할당)

#### JS를 이용해 Drag & Drop을 어떻게 구현해야 할까요?
